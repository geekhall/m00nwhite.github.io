---
layout: post
title:  "Vue 笔记 7 - Vue3"
date:   2021-09-11 13:10:25 +0800
categories: vue
---
* 目录
{:toc}

# Vue 笔记 7 - Vue3

## Vue3的变化

* 性能的提升
  - 打包大小减少 41%
  - 初次渲染快55%，更新渲染快133%
  - 内存减少54%
* 源码的升级
  - 使用`Proxy`替代`defineProperty`实现响应式
  - 重写虚拟DOM的实现和`Tree-shaking`
  - ...
* 拥抱`TypeScript`
* 新的特性
  - Composition API（组合API）（setup配置、ref与reactive、watch与watchEffect、provide与inject）
  - 新的内置组件（Fragment、Teleport、Suspense）
  - 新的生命周期钩子
  - data选项应始终被声明为一个函数
  - 移除keyCode支持作为v-on的修饰符



## 创建Vue3工程

1. 使用`vue-cli`创建
```bash
vue create vue3cli

```
2. 使用`vite`创建
Vite (法语意为 "快速的"，发音 /vit/) 是一种新型前端构建工具，能够显著提升前端开发体验。它主要由两部分组成：

* 一个开发服务器，它基于 原生 ES 模块 提供了 丰富的内建功能，如速度快到惊人的 模块热更新（HMR）。

* 一套构建指令，它使用 Rollup 打包你的代码，并且它是预配置的，可以输出用于生产环境的优化过的静态资源。

Vite 意在提供开箱即用的配置，同时它的 插件 API 和 JavaScript API 带来了高度的可扩展性，并有完整的类型支持。   

Vite 网站： 

官网：[vitejs.dev]https://vitejs.dev/

中文网：[vitejs.cn](https://vitejs.cn/)

优势：
* 开发环境中，不需要打包操作，可快速冷启动
* 轻量快速的热重载（HMR)
* 真正的按需编译，不再等待整个应用编译完成。

```bash
# 创建工程
npm init vite-app <project-name>

# 进入工程目录
cd <project-name>

# 安装依赖
npm install
# or 
yarn

# 运行
npm run dev
# or
yarn dev
```

## 安装Vue3开发者工具
Vue3的开发者工具同Vue2不同，需要单独重新安装。

## 常用Composition API

### setup
* Vue3.0中一个新的配置项，值为一个函数。
* `setup`是所有`Composition API（组合API）`表演的舞台
* 组件中所用到的：数据、方法、等等，均要配置在`setup`中
* `setup`函数的两种返回值：
  - 若返回一个对象，则对象中的属性、方法、在模板中均可以直接使用（重点关注！）
  - 若返回一个渲染函数：则可以自定义渲染内容（了解）
* 注意点：
  1. 尽量不要与Vue2.x配置混用
     - Vue2.x 配置（`data`、`methods`、`computed`...)中可以访问到setup中的属性、方法。
     - 但在setup中不能访问到Vue2.x配置（`data`、`methods`、`computed`...)
     - 如果有重名，`setup`优先
  2. setup不能是一个`async`函数，因为返回值不再是`return`的对象，而是`Promise`，模板看不到`return`对象中的属性。
     后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合。


#### setup实例

Vue2的data、methods、computed在Vue3中还是可以使用的，但是不推荐

Vue2的方法中读取Vue3中的数据和方法没有问题

但是Vue3的setup中读取不到Vue2的数据和方法
```js
export default {
  name: 'App',
  data () {
    return {
      sex: '男'
    }
  },
  methods: {
    sayWelcome(){
      alert('欢迎')
    },
    test1(){
      console.log(this.sex)           // 男
      console.log(this.sayWelcome)    // f sayWelcome(){...}
      console.log(this.name)          // 张三
      console.log(this.age)           // 18
      console.log(this.sayHello)      // f sayHello(){...}
    }
  },
  // 此处只是暂时测试一下，暂时未考虑响应式的问题。
  setup(){
    // data
    let name = '张三'
    let age = 18

    // 方法
    function sayHello(){
      alert(`我叫${name}，我${age}岁了，你好！`)
    }

    function test2(){
      console.log(this.name)            // 张三
      console.log(this.age)             // 18
      console.log(this.sayHello)        // f sayHello(){...}
      console.log(this.sex)             // undefined 
      console.log(this.sayWelcome)      // undefined
    }

    // 返回
    return {
      name,
      age,
      sayHello,
      test2
    }
  }

}
```

渲染函数

```js
// 引入渲染函数
import { h } from 'vue'

export default {
    // 渲染函数
    return ()=>{
      return h('h1', 'Geekhall')
    }
}
```

简写方式
```js
// 引入渲染函数
import { h } from '@vue/runtime-core'

export default {
    // 渲染函数简写方式
    return ()=>h('h1', 'Geekhall')
}
```

### ref函数
Vue3中需要通过ref函数来实现响应式。ref函数返回的是一个`RefImpl`对象。

作用：定义一个响应式的数据

语法：`const xxx = ref(initValue)`
* 创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。
* JS中操作数据：`xxx.value`
* 模板中读取数据：不需要.value，直接`<div>{{xxx}}</div>`

备注：
* 接受的数据可以是：基本类型、也可以是对象类型。
* 基本类型的数据：响应式依然是靠`Object.defineProperty()`的`get`与`set`完成的。
* 对象类型的数据：内部“求助”了Vue3.0中的一个新函数 ---- `reactive`函数，封装ES6的`Proxy`来实现的。


示例：
```html
<template>
  <h1>我是APP组件</h1>
  <h2>姓名：{{name}}</h2>
  <h2>年龄：{{age}}</h2>
  <h3>工作种类：{{job.type}}</h3>
  <h3>工作薪水：{{job.salary}}</h3>
  <button @click="changeInfo">changeInfo</button>
</template>

<script>
import {ref} from 'vue'

export default {
  name: 'App',
  setup(){
    // data
    let name = ref('张三')
    let age = ref(18)
    let job = ref({
      type: '全栈工程师',
      salary: '30K'
    })

    function changeInfo(){
      name.value= '李四'
      age.value = 48
      // 对象类型的Ref使用了ES6中的Proxy，可以不必
      job.value.type ='python工程师'
      job.value.salary = '35K'
      console.log(name.value, age.value)
    }

    // 返回
    return {
      name,
      age,
      job,
      changeInfo
    }
  }
}
</script>

```
### reactive函数
作用： 定义一个对象类型的响应式数据，（基本类型不要用它，要用`ref`函数）

语法：`const 代理对象 = reactive(源对象)`接收一个对象（或数组），返回一个代理对象（Proxy对象）

reactive定义的响应式数据是“深层次的”。

内部基于ES6的Proxy实现，通过代理对象操作源对象内部数据进行操作

实例：

template

```html
<h2>姓名：{{ person.name }}</h2>
<h2>年龄：{{ person.age }}</h2>
<h3>工作种类：{{ person.job.type }}</h3>
<h3>工作薪水：{{ person.job.salary }}</h3>
<h3>测试数据C：{{ person.job.a.b.c }}</h3>
<h3>爱好：{{ person.hobby }}</h3>
<button @click="changePerson">changePerson</button>
```

```js
import { reactive } from "vue";

let person = reactive({
  name: "张三",
  age: 18,
  job: {
    type: "全栈工程师",
    salary: "30K",
    a: {
      b: {
        c: 666,
      },
    },
  },
  hobby: ["抽烟", "喝酒", "烫头"]
});
function changePerson(){
  person.name = '王老五'
  person.age = 30
  person.job.type = 'python工程师'
  person.job.salary = '38K'
  person.job.a.b.c = 888
  person.hobby[2] = "打游戏"
}

return {
  person,
  changePerson
};
```

### Vue3.0中的响应式原理
#### Vue2.x中的响应式
* 实现原理
  - 对象类型： 通过`Object.defineProperty()`对属性的读取、修改进行拦截（数据劫持）。
  - 数组类型： 通过重写更新数组的一系列方法来实现拦截（对数组的方法进行了包裹）。
  ```
  Object.defineProperty(data, 'count', {
    get(){},
    set(){}
  })
  ```
* 存在问题
  - 新增属性，删除属性，界面不会更新。
  - 直接通过下表修改数组，界面不会自动更新。

#### Vue3.0的响应式
* 实现原理
  - 通过Proxy（代理）：拦截对象中任意属性的变化，包括：属性值的读写、属性的添加、属性的删除等。
  - 通过Reflect（反射）：对被代理对象的属性进行操作。
  - MDN文档中描述的Proxy与Reflect：
    1. Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy
    2. Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect
    ```js
    new Proxy(person, {
      // 有人读取p的某个属性时调用
      get(target, propName){
          console.log(`有人读取了p身上的${propName}属性`)
          // return target[propName]
          return Reflect.get(target, propName)
      },
      // 有人修改p的某个属性、或者给p追加某个属性时调用
      set(target, propName, value){
          console.log(`有人修改了p身上的${propName}属性，value=`,value)
          // target[propName] = value
          return Reflect.set(target, propName, value)
      },
      // 有人删除p的某个属性时调用
      deleteProperty(target, propName){
          console.log(`有人删除了p身上的${propName}属性`)
          // return delete target[propName]
          return Reflect.deleteProperty(target, propName)
      }
    })
    ```

* window.Reflect
  ```js
  obj
  {a: 1, b: 2}

  Reflect.get(obj, 'a')
  1

  Reflect.get(obj, 'b')
  2

  Reflect.set(obj, 'a', 20)
  true

  obj
  {a: 20, b: 2}
  
  Reflect.deleteProperty(obj,'b')
  true

  obj
  {a: 20}
  ```

### reactive对比ref
* 从定义数据角度对比
  - `ref`用来定义：*基本数据类型*
  - `reactive`用来定义： *对象（或数组）类型数据*
  - 备注：`ref`也可以用来定义*对象（或数组）类型数据*，它内部会通过`reactive`转为*代理对象*
* 从原理角度对比
  - `ref`通过`Object.deineProperty()` 的`get`与`set`来实现响应式数据劫持
  - `reactivve`通过使用`Proxy`来实现响应式数据劫持，并通过`Reflect`操作源对象内部的数据
* 从实用角度对比
  - `ref`定义的数据：操作数据需要`.value`，读取数据是模板中直接读取不需要`.value`
  - `reactive`定义的数据：操作数据与读取数据均不需要`.value`

### setup的两个注意点
* setup执行的时机
  - 在BeforeCreate之前执行一次，this是undefined
* setup的参数
  - props: 值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。
  - context: 上下文对象
    1. attrs： 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于`this.$attrs`。
    2. slots：收到的插槽内容，相当于`this.$slots`。
    3. emit：分发自定义事件的函数。相当于`this.$emit`。
### 计算属性
computed函数
* 与Vue2中computed配置功能一致
* 写法：
  ```html
  <template>
    <h1>一个人的信息</h1>
    <h2>姓：<input type="text" v-model="person.firstname"> </h2>
    <h2>名：<input type="text" v-model="person.lastname"> </h2>
    <h2>姓名： {{person.fullname}}</h2>
    <br>
    全名：<input type="text" v-model="person.fullname">
  </template>

  <script>
  import { reactive , computed} from "vue";

  export default {
    name: "Demo",
    setup() {
      // 数据
      let person = reactive({
        firstname: '张',
        lastname: '三'
      })

      // 计算属性，简写（没有考虑计算属性被修改的情况）
      // person.fullname = computed(()=>{
      //   return person.firstname + '_' + person.lastname
      // })
      // 计算属性， 完整写法(考虑读和写)
      person.fullname = computed({
        get(){
          return person.firstname + '_' + person.lastname
        },
        set(value){
          const nameAttr = value.split('_')
          person.firstname = nameAttr[0]
          person.lastname = nameAttr[1]
        }
      })

      return {
        person
      }
    },
  };
  </script>
  ```

### watch监视

Vue2.x的方式
```js
watch: {
  // 简写方式
  sum(newValue, oldValue){
    console.log('sum的值变化了', newValue,oldValue)
  }
  // 完整写法
  sum: {
    immediate:true,
    deep:true,
    handler(newValue, oldValue){
      console.log('sum的值变化了', newValue,oldValue)
    }
  }
},
```

Vue3.x的写法：
```js
<script>
import {ref, watch, reactive} from "vue";

export default {
  name: "Demo",
  // watch: {
  //   // 简写方式
  //   sum(newValue, oldValue){
  //     console.log('sum的值变化了', newValue,oldValue)
  //   }
  //   // 完整写法
  //   sum: {
  //     immediate:true,
  //     deep:true,
  //     handler(newValue, oldValue){
  //       console.log('sum的值变化了', newValue,oldValue)
  //     }
  //   }
  // },
  setup() {
    // 数据
    let sum = ref(0)
    let msg = ref('Hello Geekhall')
    let person = reactive({
      name: '张三',
      age: 20,
      job:{
        j1:{
          salary:20
        }
      }
    })

    // 情况一：监视ref所定义的响应式数据
    watch(sum, (newValue, oldValue)=>{
      console.log('sum的值变化了', newValue,oldValue)
    },{immediate:true, deep:true})
    // 情况二： 及那是ref所定义的多个响应式数据
    // 可以写两个watch
    watch(sum, (newValue, oldValue)=>{
      console.log('sum的值变化了', newValue,oldValue)
    })
    watch(msg, (newValue, oldValue)=>{
      console.log('msg的值变化了', newValue,oldValue)
    })

    // 也可以把监视对象放到一个数组中
    watch([sum,msg], (newValue, oldValue)=>{
      console.log('msg的值变化了', newValue,oldValue)
    })

    // 情况三： 监视reactive
    // 注意：此处无法获得正确的oldValue
    // 注意：强制开启了深度监视（deep:false)配置无效
    watch(person, (newValue, oldValue)=>{
      console.log('person变化了', newValue, oldValue)
    })

    // 情况四：监视reactive所定义的一个响应式数据中的某一个属性
    watch(()=>person.age, (newValue, oldValue)=>{
      console.log('person的age变化了', newValue, oldValue)
    })

    // 情况五：监视reactive所定义的一个响应式数据中的某一些属性
    watch([()=>person.age, ()=>person.name], (newValue, oldValue)=>{
      console.log('person的age或name变化了', newValue, oldValue)
    })

    // 特殊情况（监视深层次对象中时需要加上deep:true，否则监视不到）
    watch(()=>person.job, (newValue, oldValue)=>{
      console.log('person的salary变化了', newValue, oldValue)
    },{deep:true}) // 此处由于监视的是reactive所定义的对象中的某个对象属性，所以deep配置有效


    // 返回一个对象
    return {
      sum,
      msg,
      person
    }
  },
};
</script>
```
两个小坑：
* 监视reactive定义的响应式数据时：oldValue无法正确获取，强制开启了深度监视（deep配置失效）
* 监视reactive定义的响应式数据中的某个属性时：deep配置有效。

#### watchEffect函数
* watch的套路时：既要指明监视的属性，也要指明监视的回调。
* watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。
* watchEffect有点像computed：
  - 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。
  - 而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。
  ```js
  // watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
  watchEffect()=>{
    const x1 = sum.value
    const x2 = person.age
    console.log('watchEffect配置的回调执行了')
  }
  ```


### 生命周期
与Vue2.x相比：
* `beforeDestroy`和`destoryed`，换成了`beforeUnmount` 和`unmounted`
* 少了el 选项的判定
* 提供了Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：
  - beforeCreate ====> setup()
  - created =========> setup()
  - beforeMount =====> onBeforeMount
  - mounted =========> onMounted
  - beforeUpdate ====> onBeforeUpdate
  - updated =========> onUpdated
  - beforeUnmount ===> onBeforeUnmount
  - unmounted =======> onUnmounted
  


### 自定义hook函数
* 什么是hook？  --本质是一个函数，把setup函数中使用的Composition API进行了封装。
* 类似于Vue2.x中的mixin
* 自定义hook的优势：复用代码，让setup中的逻辑更清楚易懂。


### toRefs
* 作用：创建一个ref对象，其value值指向另一个对象中的某个属性
* 语法：`const name = toRef(person, 'name')`
* 应用：要将响应式对象中的某个属性单独提供给外部使用时。
* 扩展：`toRefs`与`toRef`功能一致，但可以批量创建多个ref对象，语法：`toRefs(person)`
```html
<template>
  <h2>姓名：{{name}}</h2>
  <h2>年龄：{{age}}</h2>
  <h2>薪资：{{job.j1.salary}}K</h2>
  <button @click="name+='~'">修改姓名</button>
  <button @click="age++">增长年龄</button>
  <button @click="job.j1.salary++">点我加薪</button>
</template>

```  
```js
<script>
import {ref, reactive, watchEffect, toRef, toRefs} from "vue";

export default {
  name: "Demo",
  setup() {
    // 数据
    let person = reactive({
      name: '张三',
      age: 20,
      job:{
        j1:{
          salary:30
        }
      }
    })

    const name1 = person.name
    console.log('%%%' , name1)
    const name2 = toRef(person, 'name')
    console.log('####', name2)
    
    
    // 返回一个对象
    return {
      // 注意这里如果使用ref为复制一个新的引用，修改后并不会改变person中的原值。
      // name: toRef(person, 'name'),
      // age: toRef(person, 'age'),
      // salary: toRef(person.job.j1, 'salary')

      // 使用toRefs与toRef功能一致，但可以批量创建多个ref对象，
      // 但只会展开对象的一层，比如salary就还是必须要写成job.j1.salary
      ...toRefs(person)
    }
  },
};
</script>
```

## 其他CompositionAPI
### shallowReactive 与 shallowRef
* shallowReactive：只处理对象最外层属性的响应式（浅响应式）
* shallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理。
* 什么时候使用：
  - 如果有一个对象数据，结构比较深，但变化时只是外层属性变化  ====> shallowReactive
  - 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换 =====> shallowRef

### readonly 与 shallowReadonly
* readonly: 让一个响应式数据变为只读的（深只读）
* shallowReadonly： 让一个响应式数据变为只读的（浅只读）
* 应用场景：不希望数据被修改时。

### toRaw 与markRaw
* toRaw
  - 作用： 将一个有reactive生成的响应式对象转为普通对象
  - 使用场景： 用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新
* markRaw
  - 作用：标记一个对象，使其永远不会再成为响应式对象
  - 使用场景：
    1. 有些值不应被设置为响应式的，例如复杂的第三方类库等。
    2. 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。

### customRef
* 作用： 创建一个自定义的ref， 并对其依赖项跟踪和更新触发进行显示控制
* 实现防抖效果:
  ```html
  <template>
    <input type="text" v-model="keyWord">
    <h3>{{keyWord}}</h3>
  </template>

  <script>
  import { customRef} from 'vue';

  export default {
    name: "App",
    setup(){
      function myRef(value, delay){
        let timer
        console.log('---- myRef ---- ', value)
        return customRef((track, trigger)=>{
          return {
            get(){
              console.log(`有人从myRef这个容器中读取数据了，我把${value}给他了`)
              track()     // 通知Vue追踪value的变化（提前和get商量一下，让他认为这个value是有用的。
              return value
            },
            set(newValue){
              console.log(`有人把myRef这个容器中数据改为了：${newValue}`)
              clearTimeout(timer)
              timer = setTimeout(()=>{
                value = newValue
                trigger()   // 通知Vue去重新解析模板
              }, delay)
              // value = newValue
              // trigger()   // 通知Vue去重新解析模板

            },
          }
        })
      }
      // let keyWord = ref('hello') // 使用Vue提供的ref
      let keyWord = myRef('hello', 500)  // 使用自定义的ref
      return{
        keyWord
      }
    }
  }
  </script>

  ```

### provide 与 inject
* 作用： 实现祖孙间通信
* 套路： 父组件有一个`provide`选项来提供数据，子组件有一个`inject`选项来开始使用这些数据
* 具体写法：
  - 父组件中：
  ```js
  setup(){
    let car = reactive({
      name: 'Benz',
      price: '40W'
    })

    provide('car', car) // 给自己的后代组件传递数据
    return {...toRefs(car)}
  }
  ```
  - 孙组件中：
  ```js
  setup(){
      let car = inject('car') // 接收数据
      return {car}
    }
  ```

### 响应式数据的判断
* `isRef`： 检查一个值是否为一个`ref`对象
* `isReactive`： 检查一个对象是否是由`reactive`创建的响应式代理
* `isReadonly`： 检查一个对象是否是由`readonly`创建的只读代理
* `isProxy`： 检查一个对象是否是由`reactive`或者`readonly`方法创建的代理


## Composition API的优势
1. Options API存在的问题
   使用传统Options API中，新增或者修改一个需求，需要分别在data,methods,computed里修改。
2. Composition API的优势
   我们可以更加优雅的组织我们的代码，函数，让相关功能的代码更加有序的组织在一起。

## 新的组件
### Fragment
* 在Vue2中，组件必须有一个根标签
* 在Vue3中，组件可以没有根标签，内部会将多个标签包含在一个Fragment虚拟元素中。
* 好处，减少标签层级，减小内存占用

### Teleport
Teleport是一种能够将我们的组件html结构移动到指定位置的技术
```
```

### Suspense
* 等待异步组件时渲染一些额外内容，让应用有更好的用户体验
* 使用步骤
  - 异步引入组件
    ```js
    import {defineAsyncComponent} from 'vue'
    const Child = defineAsyncComponent(()=>import('./components/Child')) // 异步引入
    ```
  - 使用`Suspense`包裹组件，并配置好`default`与`fallback`
    ```xml
    <Suspense>
      <template v-slot:default>
        <Child/>    
      </template>
      <template v-slot:fallback>
        <h3>加载中。。。稍等</h3>
      </template>
    </Suspense>
    ```


## 其他
* Vue2.x有许多全局API和配置
  - 例如： 注册全局组件、注册全局指令等
  ```js
  // 注册全局组件
  Vue.component('MyButton', {
    data: ()=> ({
      count: 0
    }),
    template: '<button @click="count++">Clicked {{ count }} times.</button>'
  })
  )

  // 注册全局指令
  Vue.directive('focus', {
    Inserted: el => el.focus()
  })
  ```
* Vue3.0中对这些API做出了调整
  - 将全局的API，即Vue.xxx调整到应用实例app上
  
  |2.x全局API（Vue）|3.x实例API（app）|
  |----|----|
  |Vue.config.xxxx|app.config.xxxx|
  |Vue.config.productionTip|移除|
  |Vue.Component|app.component|
  |Vue.directive|app.directive|
  |Vue.mixin|app.mixin|
  |Vue.use|app.use|
  |Vue.prototype|app.config.globalProperties|
* 其他改变
  - data选项应始终被声明为一个函数
  - 过度类名的更改：

  Vue2.x写法
  ```js
  .v-enter,
  .v-leave-to {
    opacity: 0;
  }
  .v-leave,
  .v-enter-to{
    opacity: 1;
  }
  ```

  Vue3.0的写法
  ```js
  .v-enter-from,
  .v-leave-to {
    opacity: 0;
  }
  .v-leave-from,
  .v-enter-to{
    opacity: 1;
  }
  ```
  - 移除了KeyCode作为v-on的修饰符，同时也不再支持`config.keyCodes`
  - 移除`v-on.native`修饰符
  
  父组件中绑定事件  
  ```js
  <my-component
    v-on:close="handleComponentEvent"
    v-on:click="handleNativeClickEvent"
  />
  ```
  
  子组件中声明自定义事件
  ```js
  <script>
    export default {
      emits: ['close']
    }
  </script>
  ```
  - 移除过滤器（filter）
  过滤器虽然看起来很方便，但它需要一个自定义语法，打破大括号内表达式“只是JavaScript”的假设，
  这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。