---
git@gitee.com:sjdt/geekhall.cn.gitlayout: post
title:  "ES6 笔记"
date:   2021-08-22 12:10:25 +0800
categories: ES6
---

# ES6笔记

## ES6特性
### let与var的区别：
* 使用let声明变量，不能重复声明
* 块儿级作用域
* 不存在变量提升
* 不影响作用域链

### 使用const声明常量时一定要赋初始值

### 解构赋值
ES6允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。
1. 数组的解构
   ```javascript
   const F4=['小沈阳','刘能','赵四','宋小宝']
   let [a,b,c,d] = F4;
   console.log(a);
   ```
2. 对象的解构
   ```javascript
   const zhao = {
        name: '赵本山',
        age: 60,
        xiaopin: function(){
            console.log("赵本山会演小品.");
        }
    }
    //zhao.xiaopin();
    let {xiaopin} = zhao;
    xiaopin();
    ```

3. ES6 引入了新的声明字符串的方式：``
反引号内容中可以直接出现换行符

梵音好重可以使用${}来进行变量拼接
```javascript
let act="葛优";
let msg=`${act}是一个好演员`;
```

4. ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。
   ```javascript
    let name = "极客堂";
    let change = function (){
        console.log("我们可以改变你！");
    }

   const school = {
       // 
       // name: name,
       // change: change,
       // 属性名和变量名相同时，可以省略成下面的形式
        name,
        change, 
        origin: function(){
            console.log("原来的方法定义方式。")
        },
        improve(){
            console.log("ES6支持的方法定义方式。")
        }
    }

    console.log(school);
    school.origin();
    school.improve();
   ```
5. ES6允许使用箭头 （=>） 定义函数。
```javascript
let fn = function(){
    console.log("function1");
}

let fn1 = (a,b) => {
    console.log("function2");
    return a + b;
}

fn();
fn1(1,2);
```

需要注意的：
* this是静态的，this始终指向函数声明时所在作用域下的this的值。
```javascript
function getName(){
        console.log(this.fname);
    }
    let getName2 = () => {
        console.log(this.fname);
    }

    window.fname = "name in window";
    const geekA = {
        fname: "name in geekA"
    }

    // 直接调用，都返回"name in window"
    getName(geekA);
    getName2(geekA);

    // call 方法调用则不同
    // 由于getName2方法声明时，this指向window，
    // 所以函数内也一直指向window
    getName.call(geekA);    //  name in geekA
    getName2.call(geekA);   //  name in window
```

* 不能作为构造实例化对象
```javascript
// 不能作为构造实例化对象，
// 比如下面的代码会报错：Uncaught TypeError： Person is not a constructor.
let Person = (name, age) => {
    this.name = name;
    this.age = age;
}
let me = new Person('xiao', 30);
console.log(me);
```

* 不能使用arguments变量
```javascript
// 比如下面的代码会报错：Uncaught ReferenceError： argumenets is not defined.
let fn = () => {
    console.log(arguments);
}
fn(1,2,3);
```
* 箭头函数的简写
```javascript
// 箭头函数的简写
// 当形参有且只有一个的时候可以省略小括号：
let fn_add = n => {
    return n+n;
}
console.log(fn_add(3));

// 当代码体只有一条语句的时候，可以省略花括号：
// 省略花括号时return也必须省略。
let fn_pow = n => n*n;
console.log(fn_pow(4));
```
* 箭头函数的实践
```html
    <title>箭头函数实践</title>
    <style>
        div{
           width: 200px;
           height: 200px;
           background: #58a; 
           margin:2rem;
        }
    </style>
</head>
<body>
    <div id="ad"></div>

    <div id="ad2"></div>
    <script>
        // 需求-1 点击div 2s 后颜色变成粉色
        let ad = document.getElementById('ad');
        ad.addEventListener("click", function(){ 
            // 注意这里不能在定时器种直接使用this，
            // 因为定时器中的this指向window。
            // 所以这里需要使用self临时保存this。
            let self = this;
            setTimeout(function(){
                console.log(self);
                console.log(this);
                // 这里使用this会报错，因为当前内层函数的this指向了window
                // this.style.background = 'pink';

                // 这里在内层函数中找不到self，就会继续向外层函数查找self
                self.style.background = 'pink';

            }, 2000);
        })

        // 而有了箭头函数之后，上面的问题就可以得到解决了
        let ad2 = document.getElementById('ad2');
        ad2.addEventListener("click", function(){ 
            setTimeout(() => {
                console.log(self);
                console.log(this);
                this.style.background = 'pink';
            }, 2000);
        })
    </script>
</body>
```

箭头函数可以使函数更加简洁，例如下面的取数组偶数项的函数：
```javascript
const arr = [1,2,3,4,5,6];
const result = arr.filter(function(item){
    if(item % 2 === 0 ){
        return true;
    } else {
        return false;
    }
});
```
可以简化为：
```javascript
const result2 = arr.filter(item => item % 2 === 0);
```

需要注意的是箭头函数不适合与`this`有关的回调，事件回调，对象的方法。



### ES6 允许给函数参数赋初始值

```javascript
function add(a,b,c=10){
    return a+b+c;
}

console.log(add(1+2)); //13
```

参数默认值可以与解构赋值结合使用
```javascript
function connect({host="127.0.0.1", username, password, port}){
    console.log(host);
    console.log(username);
    console.log(password);
    console.log(port);
};
connect({
    host: 'localhost',
    username: 'root',
    password: '123456',
    port: 3306
});

```
### ES6 引入了rest参数，用于获取函数的实参，用来代替arguments
注意rest参数必须要放到参数的最后
```javascript
// ES5 的方式
// Arguments是一个对象
function normal_fn(){
    console.log(arguments);
}

normal_fn('a','b','c',100)

// ES6 的方式（REST方式）
// args是一个数组，参数处理更加灵活。
function normal_fn2(arg1, arg2, ...args){
    console.log(args);
}

normal_fn2('a','b','c',200);
```


### ... 扩展运算符能将数组转换为逗号分隔的“参数序列”
```javascript
const tfboys = ['易洋千玺','王源','王俊凯'];

function chunwan(){
    console.log(arguments);
}

chunwan(tfboys);
chunwan(...tfboys); // 等同于chunwan('易洋千玺','王源','王俊凯')
```
![](https://yinyang.space/img/20210821_es6_1.png)


可以用来数组的合并或者克隆

```javascript
const kuaizi = ['王太利', '肖央'];
const fenghuang = ['曾毅', '玲花'];
const zuixuanxiaopingguo = kuaizi.concat(fenghuang);
const zxxpg = [...kuaizi, ...fenghuang]
console.log(zuixuanxiaopingguo);
console.log(zxxpg);

const arr1 = ['a','b','c'];
const arr2 = [...arr1];

```



### ES6引入了Symbol
ES6引入了一种新的原始数据类型Symbol，表示一种独一无二的值，它是JavaScript语言的第七种数据类型。
是一种类似于字符串的数据类型。
Symbol的特点：
* Symbol的值是唯一的，用来解决命名冲突的问题
* Symbol值不能与其他数据类型进行运算
* Symbol定义的对象属性不能使用`for...in`循环遍历，但是可以使用`Reflect.ownKeys`来获取对象的所有键名。

```javascript
let s = Symbol();
console.log(s, typeof s);

let s2 = Symbol("GeekHall");
let s3 = Symbol("GeekHall");

console.log(s2 === s3); // false 


let s4 = Symbol.for('GeekHall');
let s5 = Symbol.for('GeekHall');
console.log(s4, typeof s4);

console.log(s4 === s5); // true
```

### JavaScript数据类型
```
USONB you are so niubility!
u : undefined
s : string symbol
o : object 
n : null number
b : boolean


```


可以使用Symbol安全地向对象追加方法：
下面的game中已经有一个up方法了，使用Symbol可以保证原对象中的方法不会被覆盖。
```javascript

let game = {
    name: '俄罗斯方块',
    level:10,
    up: function() {
        console.log("up method");
    }
}

let methods = {
    up: Symbol(),
    down: Symbol()
};

game[methods.up] = function() {
    console.log("改变形状");
}

game[methods.down] = function() {
    console.log("快速下降");
}

console.log(game);
```

![](https://yinyang.space/img/20210821_es6_2.png)


### 给对象添加Symbol类型的属性：
```javascript
let say = Symbol('say');
let zibao = Symbol('zibao');
let youxi = {
    name: "狼人杀",
    [say]: function() {
        console.log("我可以发言");
    },
    [zibao]: function() {
        console.log("我可以自爆");
    }
};

console.log(youxi);
youxi[say]();       // 打印 我可以发言
youxi[zibao]();     // 打印 我可以自爆
```






### Symbol内置值
ES6提供了11个内置的Symbol值
|值|用途|
|---|---|
|Symbol.hasInstance|当其他对象使用instanceof运算符，判断是否为该对象的实例时会调用这个方法|
|Symbol.isConcatSpreadable |对象的Symbol.isConcatSpreadable属性等于的是一个bool值，表示该对象用于Array.prototype.concat()时，是否可以展开 |
|Symbol.unscopables |该对象使用with关键字时，哪些属性会被with环境排除 |
|Symbol.match |当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值 |
|Symbol.replace |当该对象被str.replace(myObject)方法调用时，会返回该方法的返回值。 |
|Symbol.search |当该对象被str.search(myObject)方法调用时，会返回该方法的返回值。 |
|Symbol.split |当该对象被str.split(myObject)方法调用时，会返回该方法的返回值。 |
|Symbol.iterator |对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认迭代器 |
|Symbol.toPrimitive |该对象被转为原始类型值时，会调用这个方法，返回该对象对应的原始类型值 |
|Symbol.toStringTag |在该对象上面调用toString方法时，返回该方法的返回值 |
|Symbol.species |创建衍生对象时，会使用该属性 |





```javascript
class Person{
    static [Symbol.hasInstance](param){
        console.log("我被用来检测类型了！");
    }
}

let o = {};
console.log(o instanceof Person); 
// 打印：
// 我被用来检测类型了！
// false
```

```javascript
const arr = [1,2,3]
const arr2 = [4,5,6]
arr2[Symbol.isConcatSpreadable] = false;
console.log(arr.concat(arr2));

```
![](https://yinyang.space/img/20210821_es6_3.png)






### 迭代器
迭代器（iterator）是一种接口，为各种不同数据结构提供统一的访问机制。
任何数据结构之遥部署了iterator接口就可以完成遍历操作。
* ES6创造了一种新的遍历命令：for...of循环，iterator接口主要供for...of消费。
* 原生具备iterator接口的数据包括：
  - Array
  - Arguments
  - Set
  - Map
  - String
  - TypedArray
  - NodeList

```javascript
const books = ['西游', '红楼','水浒', '三国'];

for (let book of books){
    console.log(book);
}
```

使用iterator可以自定义对象的遍历方法
```javascript
const actors = {
    name: "四大才子",
    code:[
        "刘能",
        "小沈阳",
        "宋小宝",
        "赵四"
    ],
    [Symbol.iterator](){
        let index = 0;
        let self = this;
        return {
            next: function(){
                if (index < self.code.length){
                    const result = {
                        value: self.code[index], 
                        done: false
                    };
                    index++;
                    return result;
                } else {
                    return {value:undefined, done: true};
                }
            }
        };
    }
}

for (let actor of actors){
    console.log(actor);
}

```

### 生成器
生成器其实就是一个特殊的函数，是一种异步编程的解决方案，
在声明函数的时候在函数名前加一个星号 * ，使用的时候借助iterator的next()方法来调用。

```javascript
function * gen(){
    console.log("111");
    yield '一只没有耳朵';

    console.log("222");
    yield '一只没有尾巴';

    console.log("333");
    yield '真奇怪';

    console.log("444");

    let iter = gen();
    iter.next();
    console.log("============华丽的分割线1============");
    iter.next();
    console.log("============华丽的分割线2============");
    iter.next();
    console.log("============华丽的分割线3============");
    iter.next();
}

```
![](https://yinyang.space/img/20210821_es6_4.png)


```javascript
for (let v of gen()){
    console.log("============华丽的分割线============");
    console.log(v);
}
```
打印结果：

![](https://yinyang.space/img/20210821_es6_5.png)

可以看到每次调用`next`的返回值为`yield`后定义的值。


### 生成器的使用实例1: 解决回调地狱问题

可以用来解决回调地狱，比如下面的代码：
```javascript
setTimeout(() => {
    console.log("1111");
    setTimeout(() => {
        console.log("2222");
        setTimeout(() => {
            console.log("3333");
        }, 3000);
    }, 2000);
}, 1000);

```

可以优化成：

```javascript
function one(){
    setTimeout(() => {
        console.log("1111");
        iterator.next();
    }, 1000)
}

function two(){
    setTimeout(() => {
        console.log("2222");
        iterator.next();
    }, 2000)
}

function three(){
    setTimeout(() => {
        console.log("3333");
        iterator.next();
    }, 3000)
}

function * gen(){
    yield one();
    yield two();
    yield three();
}

let iterator = gen();
iterator.next(); 
```

### 生成器的使用实例2: 模拟获取用户数据、订单数据、商品数据

```javascript
function getUsers(){
    setTimeout(() => {
        let data = '用户数据';
        // 调用next方法，并且将数据传入
        iterator.next(data);
    }, 1000);
}

function getOrders(){
    setTimeout(() => {
        let data = '订单数据';
        iterator.next(data);
    }, 1000);
}

function getGoods(){
    setTimeout(() => {
        let data = '商品数据';
        iterator.next(data);
    }, 1000);
}

function * gen(){
    let users = yield getUsers();
    console.log(users);

    let orders = yield getOrders();
    console.log(orders);

    let goods = yield getGoods();
    console.log(goods);
}

let iterator = gen();
iterator.next();
```




### Promise
Promise时ES6引入的异步编程的新解决方案。语法上Promise是一个构造函数，
用来封装异步操作，并可以获取其成功或失败的结果。
* Promise 构造函数：Promise(excutor){}
* Promise.prototype.then 方法
* Promise.prototype.catch 方法


resolve函数（处理成功）会调用then中的成功处理函数
```javascript
        const p = new Promise(function(resolve, reject){
            setTimeout(function(){
                // resolve函数（处理成功）会调用then中的成功处理函数
                let data = '数据库中的用户数据';
                resolve(data);
            }, 1000)
        });
        p.then(function(value){
            console.log("success.");
            console.log(value);
        }, function(reason){
            console.log("failed");
            console.log(reason);
        })
```

![](https://yinyang.space/img/20210823_promise1.png)


reject函数（处理失败）会调用then中的失败处理函数
```javascript
        const p = new Promise(function(resolve, reject){
            setTimeout(function(){
                // reject函数（处理失败）会调用then中的失败处理函数
                let err = '数据读取失败';
                reject(err);
            }, 1000)
        });
        p.then(function(value){
            console.log("success.");
            console.log(value);
        }, function(reason){
            console.log("failed");
            console.log(reason);
        })
```


![](https://yinyang.space/img/20210823_promise02.png)

上面的实例演示了如何将异步任务封装在`Promise`对象中，
并通过resolve和reject函数改变任务状态，
从而调用then方法中对应的成功或者失败回调函数。



#### 实例：使用Promise封装文件读取操作


不使用Promise的文件读取操作：
```javascript
// 1. 引入fs模块
const fs = require('fs');


// 2. 调用方法读取文件
fs.readFile('./resources/sample6_promise.md', (err, data) => {
    // 如果失败则抛出错误
    if (err) throw err;

    // 如果没有出错，则输出内容
    console.log(data.toString());
})
```

将文件保存后使用node执行：
```bash
➜  es6_sample git:(main) ✗ node promise_readfile.js  
# Promise 教程
Promise时ES6引入的异步编程的新解决方案。语法上Promise是一个构造函数，
用来封装异步操作，并可以获取其成功或失败的结果。
* Promise 构造函数：Promise(excutor){}
* Promise.prototype.then 方法
* Promise.prototype.catch 方法
```

通过Promise对文件读取操作进行封装：

```javascript
// 1. 引入fs模块
const fs = require('fs');

const p = new Promise( function (resolve, reject) {
    fs.readFile("./resources/sample6_promise.md", (err, data) => {
        // 判断如果失败
        if (err) reject(err);

        // 判断如果成功，则通过调用resolve改变状态为成功。
        resolve(data);
    });
});

p.then(function (value){
    console.log(value.toString());
}, function (reason) {
    console.log("读取失败！");
    console.log(reason);
})

```


#### 实例： 使用Promise封装Ajax

不使用Promise：

```javascript
// 创建对象
const xhr = new XMLHttpRequest();

// 初始化
xhr.open("GET", "https://api.apiopen.top/getJoke");

// 发送
xhr.send();

// 绑定事件，处理响应结果
xhr.onreadystatechange = function(){
    // 判断
    if (xhr.readyState == 4){
        if (xhr.status >= 200 && xhr.status < 300){
            // 表示成功
            console.log(xhr.response);
        } else {
            // 失败
            console.error(xhr.status);
        }
    }
}

```

使用Promise：
```javascript
const p = new Promise(function(resolve, reject){

    const xhr = new XMLHttpRequest();
    xhr.open("GET", "https://api.apiopen.top/getJoke");
    xhr.send();

    // 绑定事件，处理响应结果
    xhr.onreadystatechange = function(){
        // 判断
        if (xhr.readyState == 4){
            if (xhr.status >= 200 && xhr.status < 300){
                // 表示成功
                // console.log(xhr.response);
                resolve(xhr.response);
            } else {
                // 失败
                reject(xhr.status);
                // console.error(xhr.status);
            }
        }
    }
});

p.then(function(value){
    console.log(value);
}, function(reason){
    console.error(reason);
});

```



#### Promise 对象的then方法
调用then方法， then方法的返回结果为Promise对象，
对象状态由回调函数的执行结果决定
1. 若回调函数中返回的结果不是Promise类型的属性，则返回的Promise的状态为成功，返回值为对象的成功的值。
   例如：
   ```javascript
    const p = new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("用户数据");
            // reject("出错啦！");
        }, 1000)
    });

    // 调用then方法， then方法的返回结果为Promise对象，
    // 对象状态由回调函数的执行结果决定
    // 1. 若回调函数中返回的结果是 非Promise类型的属性，状态为成功，返回值为对象的成功的值。
    // 2. 若回调函数中返回的结果是 Promise类型的属性，则内部Promise的状态决定返回Promise的状态。
    const result = p.then(value => {
        console.log(value);
        // case 1
        // return 'geekhall';
        // case 2
        return new Promise((resolve, reject) => {
            resolve("OK");
        })
    }, reason => {
        console.error(reason);
    });

    console.log(result);
   ```

执行结果(case 1)：

![](https://yinyang.space/img/20210823_promise_3.png)


执行结果(case 2)：

![](https://yinyang.space/img/20210823_promise_4.png)


then方法是可以链式调用的。
```javascript
p.then(value => {
    // do something    
}).then(value => {
    // do something    
}).then(value => {
    // do something    
});

```

一个读取多个文件的例子

```javascript

const fs = require('fs');
const p = new Promise((resolve, reject) => {
    fs.readFile("./resources/file1.md", (err, data) => {
        resolve(data);
    });
});

p.then(value => {
    return new Promise((resolve, reject) => {
        fs.readFile("./resources/file2.md", (err, data) => {
            resolve([value, data]);
        });
    });
}).then(value => {
    return new Promise((resolve, reject) => {
        fs.readFile("./resources/file3.md", (err,data) => {
            value.push(data);
            resolve(value);
        });
    });
}).then(value => {
    console.log(value.join('\r\n'));
})
```















```javascript

```

```javascript

```

```javascript

```
